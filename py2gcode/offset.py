# -*- coding: utf-8 -*-

#Стратегия, которая расчитывает offset для сложных фигур
#алгоритм тупой до безобразия: по всей траектории создаем маленькие точки с заданным шагом. И на каждом шаге "рисуем" окружность-фрезу, и по этим окружностям строим касательные
#Как бы маленькими шажочками

from svg import *
from main import *
from trajectory import *
from tool import *
from strategy import *
from meta import *

default_safeZ = 5

class Offset(Meta):
    def __init__(self, t, offset):#, x_start, y_start):
        super(Offset,  self).__init__()
        #self.x_start = x_start
        #self.y_start = y_start
        self.offset = offset
        self.src = t #начальная траектория

        #создаем мета-траекторию
        if len(self.src.points) == 0:
            self.src.create_trajectory()

        #удалим отрезки нулевой длины
        prev = t.points[0]
        tmp = [prev]        
        for p in t.points[1:]:
            len2 = get_len(prev,  p)

            if len2 != 0:
                tmp.append(p)
            prev = p
        t.points = tmp

        min_len = 0.001 #минимальная длина отрезка, ради которой стОи что-то считать
        i = 0
        while i < len(t.points) - 2:
            s = Point(t.points[i]['x'], t.points[i]['y'])
            s_prev = get_from_ring(t.points, i, -1)
            s_prev = Point(s_prev['x'], s_prev['y'])
            s_past = get_from_ring(t.points, i, 1)
            s_past = Point(s_past['x'], s_past['y'])

            #if i == 0 and s_prev.x == s.x and s_prev.y == s.y: #контур замкнутый, то последняя точка == первой, исправляем
            #    s_prev = get_from_ring(t.points, i, -2)
            #    s_prev = Point(s_prev['x'], s_prev['y'])

            #if i == len(t.points) - 1 and s_past.x == s.x and s_past.y == s.y: #контур замкнутый, то последняя точка == первой, исправляем
            #    s_past = get_from_ring(t.points, i, 2)
            #    s_past = Point(s_past['x'], s_past['y'])

            if dist(s, s_past) == 0 or dist(s, s_prev) == 0:
                i += 1
                continue

            zero = Point(s.x + 100, s.y)
            a = get_angle(s_prev, s, s, s_past)
            aa = a*180.0/3.14159265358979323
            
            if offset > 0: #обводим снаружи
                if aa > 180: #внутренний угол
                    self.point(s.x, s.y, radius=-self.offset)            
                else:
                    pp1 = get_border(s_prev, s, self.offset)
                    pp2 = get_border(s, s_past, self.offset)
                    pp = get_cross_point(pp1[0], pp1[1], pp2[0], pp2[1])
                    self.point(pp.x, pp.y)
            else:
                if aa < 180: #внутренний угол
                    self.point(s.x, s.y, radius=-self.offset)            
                else:
                    pp1 = get_border(s_prev, s, self.offset)
                    pp2 = get_border(s, s_past, self.offset)
                    pp = get_cross_point(pp1[0], pp1[1], pp2[0], pp2[1])
                    self.point(pp.x, pp.y)
                    
            i += 1

if __name__ == '__main__':
#    str = 'm 26.375797,-199.69209 c -0.743175,5.1898 -0.605986,14.11446 3.500577,21.48348 4.106564,7.36901 17.023812,14.92751 28.541993,15.00196 11.518181,0.0744 22.231005,-4.04074 29.080635,-2.69265 6.84963,1.34809 16.841128,12.84577 18.558968,17.93726 -2.65497,6.15181 -11.378568,5.75807 -16.404848,8.71999 -1.4269,1.06002 -3.57527,3.37468 -1.34632,6.46236 1.93668,2.85864 23.188378,-5.06676 32.581098,9.96282 3.45557,5.7892 10.71316,14.66647 7.53942,16.96371 0.0224,0.86389 -6.82138,0.71804 -10.23207,1.07706 -1.77208,0.1876 -1.64017,3.23118 0.53853,4.846773 12.61059,10.50134 18.75881,31.90793 17.23297,56.5457 -2.05596,19.722015 -10.49029,36.4929249 -20.73342,36.8893249 -10.00654,0.7809 -16.966678,-3.6740999 -18.310048,-15.0788399 -0.58769,-3.85122 -1.14271,-14.22222 10.232078,-16.694445 9.7685,-1.38635 11.93706,8.797745 11.57842,12.386205 -0.35864,3.58846 -3.6634,6.29488 -7.8441,8.20238 -0.8119,0.3704 -2.20829,2.0247 -0.7724,3.0731 2.78485,1.7165 7.3142,1.5848 12.38621,-3.4668 5.07201,-5.0515 4.39464,-19.380775 -0.8078,-30.696235 -3.84313,-8.92387 -10.35187,-21.46531 -12.38621,-24.7724 -2.48047,-4.2132 -7.35742,-5.3902 -9.15501,-3.50045 -1.797588,1.88975 -0.167968,7.199836 2.24932,11.20322 2.41729,4.003384 4.99278,14.612385 3.39311,18.207399 -0.34159,0.767664 -1.10159,1.283243 -1.60346,1.285621 -4.936528,0.56097 -18.382368,-1.80194 -21.339258,-10.50135 -2.95689,-8.69941 -1.91348,-14.31521 -3.7024,-20.93537 -1.78893,-6.62015 -8.36683,-8.17514 -9.5589,-0.87511 -1.192081,7.30004 7.596269,20.456037 2.01947,21.27195 -6.013585,0.8078 -21.075935,-9.52751 -31.773285,-29.88843 -10.69735,-20.360923 -29.090241,-65.127113 -25.04167,-103.397843 1.92432,-15.39344 6.69801,-22.59508 13.86716,-28.67675 7.16915,-6.08167 17.77657,-5.78507 26.99582,-1.08664 9.21926,4.69843 14.597105,21.82148 10.29741,28.9556 -4.29968,7.13411 -8.07989,8.48157 -14.67495,7.53942 -6.59505,-0.94215 -10.66933,-7.31307 -9.82818,-13.73252 0.84115,-6.41945 5.84214,-9.02168 9.42428,-8.88576 3.58214,0.13592 4.35313,1.14438 5.58726,2.08681 1.936175,1.20701 2.890072,-1.0983 2.121922,-2.43546 -2.461025,-4.284 -5.07646,-7.08811 -11.209632,-8.26784 -6.133172,-1.17972 -13.003144,1.59443 -15.75201,4.57751 -2.748866,2.98308 -4.507505,5.71544 -5.25068,10.90524 z'
    str = 'm 8.5518444,-108.92843 c 1.4948896,20.161912 5.2547266,45.118986 30.9392166,61.960266 25.684484,16.84128 37.732634,21.36533 42.449184,29.50532 4.716538,8.1399835 2.0527,16.2264435 -8.34722,14.2710535 C 63.193105,-5.1471805 37.331975,-18.147884 21.542272,-45.093024 5.7525688,-72.038154 4.4283794,-104.03584 5.3450277,-108.74695 c 0.3416653,-2.26348 3.0669059,-2.02972 3.2068167,-0.18148 z'
    t = SvgTrajectory(str)
    #t = Meta()
    #t.point(0, 0)
    #t.point(0, 100)
    #t.point(100, 100)
    #t.point(100, 0)    

    o = Offset(t, 1.5)
    o2 = Offset(t, -1.5)

    preview2D([t, o, o2], 5, options={'hideRef': True})

    def f():
        G0(0, 200, 5)
        c = Strategy()
        c.mill(o, x=0, y=0, options={'z': -10})
        G0(Z=5)
        c.mill(o2, x=0, y=0, options={'z': -10})
        G0(Z=5)
        c.mill(t, x=0, y=0, options={'z': -10})
    
    preview(f)
